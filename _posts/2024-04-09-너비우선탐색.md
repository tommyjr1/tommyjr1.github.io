---
title: "TIL: BFS"
date: 2024-04-09T13:19:05.068Z
tags:
  - TIL
categories:
  - Python
  - Algorithm
description: 단순 조건문은 한줄에 정리하기
slug: 너비우선탐색
keywords:
  - BFS
draft: true
---

# BFS

이거는 그래도 많이 본 아이.
**시작점에서 뻗어나가는 맵 문제 유형**

## Code

~~heapq~~ deque.맨날 헷갈려!!

```py
from collections import deque

def solution(maps):
  ans=0
  m=len(maps[0])
  n=len(maps)
  visited = [[False]*m for _ in range(n)]

  #bfs를 따로 함수로 빼진 않고, 메인 함수가 이거일 때는 많음.
  def bfs(maps, x,y, visited):
    q = deque()
    q.append((y,x))
    #큐에 넣는 순간 visit한거로 취급!!!!
    visited[y][x]=True

    d = [0,1,2,3]
    dx=[+1,0,-1,0]
    dy = [0,-1,0,+1]

    while q:
      cy, cx = q.popleft()
      for i in d:
        nx = cx+dx[i]
        ny = cy+dy[i]
        if 0<=nx<m and 0=<ny<n and maps[ny][nx]!=0:
          if not visited[ny][nx]:
            q.append((ny,nx))
            visited[ny][nx]=True
            #여기서 할 일이 다양한데, 최단거리는 주로 노드자체의 합을 더하는 편인듯.
            maps[ny][nx] = maps[cy][cx]+1

    #BFS는 큐 다 읽고난 다음에 리턴값을 지정. BT랑 다름.
    if maps[n-1][m-1]==1:
      return -1
    else: return maps[n-1][m-1];

  ans = bfs(maps, 0,0, visited)
  return ans





```

## 문제 유형

**맵 찾기 - 시작점에서 뻗어나가는경우**<br>
미로를 빠져나가는 최단거리.

[프로그래머스 미로찾기](https://school.programmers.co.kr/learn/courses/30/lessons/1844)

- 대표적인 BFS. 칸을 1칸으로 생각하고 지금까지 온 길 값을 계속 더해감!!

[프로그래머스 네트워크](https://school.programmers.co.kr/learn/courses/30/lessons/43162)

-

[백준 연구소](https://www.acmicpc.net/problem/14502)

-

[백준 인구이동](https://www.acmicpc.net/problem/16234)

-
